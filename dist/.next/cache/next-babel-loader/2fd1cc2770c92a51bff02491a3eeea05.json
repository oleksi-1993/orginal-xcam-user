{"ast":null,"code":"import { flatten } from 'lodash';\nimport { put, select } from 'redux-saga/effects';\nimport { createSagas } from '@lib/redux';\nimport { messageService } from '@services/message.service';\nimport { message } from 'antd';\nimport { getConversations, getConversationsSuccess, getConversationsFail, setActiveConversation, setActiveConversationSuccess, loadMessages, fetchingMessage, loadMessagesSuccess, sendMessage, sendMessageFail, sendMessageSuccess, getConversationDetail, getConversationDetailSuccess, readMessages, loadMoreMessages, loadMoreMessagesSuccess, searchConversations, searchConversationsFail, searchConversationsSuccess, updateLastMessage, loadMoreMessagesFail, loadMessagesFail, setActiveConversationFail } from './actions';\nconst conversationSagas = [{\n  on: getConversations,\n\n  *worker(data) {\n    try {\n      const resp = yield messageService.getConversations(data.payload);\n      yield put(getConversationsSuccess(resp.data));\n    } catch (e) {\n      // TODO - alert error\n      const error = yield Promise.resolve(e);\n      yield put(getConversationsFail(error));\n    }\n  }\n\n}, {\n  on: searchConversations,\n\n  *worker(data) {\n    try {\n      const resp = yield messageService.getConversations(data.payload);\n      yield put(searchConversationsSuccess(resp.data));\n    } catch (e) {\n      // TODO - alert error\n      const error = yield Promise.resolve(e);\n      yield put(searchConversationsFail(error));\n    }\n  }\n\n}, {\n  on: setActiveConversation,\n\n  *worker(data) {\n    try {\n      const {\n        source,\n        sourceId,\n        conversationId,\n        recipientId\n      } = data.payload;\n      const conversationMapping = yield select(state => state.conversation.mapping);\n\n      if (conversationId) {\n        // todo - check me later\n        if (conversationMapping[conversationId]) {\n          yield put(setActiveConversationSuccess(conversationMapping[conversationId]));\n          const readAllMessages = yield messageService.readAllInConversation(conversationId, recipientId);\n\n          if (readAllMessages) {\n            yield put(readMessages(conversationId));\n          }\n\n          yield put(loadMessages({\n            conversationId,\n            limit: 25,\n            offset: 0\n          }));\n        } else {// TODO - check me later, query to DB and update here\n        }\n      } else {\n        const resp = yield messageService.createConversation({\n          source,\n          sourceId\n        });\n        const conversation = resp.data;\n\n        if (conversationMapping[conversation._id]) {\n          yield put(setActiveConversationSuccess(conversationMapping[conversation._id]));\n        } else {\n          yield put(setActiveConversationSuccess(conversation));\n        }\n\n        yield put(loadMessages({\n          conversationId: conversation._id,\n          limit: 25,\n          offset: 0\n        }));\n      }\n    } catch (e) {\n      message.error('Error occured, please try again later');\n      yield put(setActiveConversationFail(e));\n    }\n  }\n\n}, {\n  on: getConversationDetail,\n\n  *worker(data) {\n    try {\n      const conversation = yield messageService.getConversationDetail(data.payload.id);\n      yield put(getConversationDetailSuccess(conversation.data));\n    } catch (e) {\n      yield put(getConversationsFail(e));\n    }\n  }\n\n}];\nconst messageSagas = [{\n  on: loadMessages,\n\n  *worker(data) {\n    try {\n      const messageMap = select(state => state.message.mapping);\n      const {\n        conversationId,\n        offset,\n        limit\n      } = data.payload;\n\n      if (messageMap[conversationId] && messageMap[conversationId].fetching) {\n        // do nothing if it is fetching\n        return;\n      }\n\n      yield put(fetchingMessage({\n        conversationId\n      }));\n      const resp = yield messageService.getMessages(conversationId, {\n        offset,\n        limit\n      });\n      yield put(loadMessagesSuccess({\n        conversationId,\n        items: resp.data.data,\n        total: resp.data.total\n      }));\n    } catch (e) {\n      message.error('Error occured, please try again later');\n      yield put(loadMessagesFail(e));\n    }\n  }\n\n}, {\n  on: loadMoreMessages,\n\n  *worker(data) {\n    try {\n      const messageMap = select(state => state.message.mapping);\n      const {\n        conversationId,\n        offset,\n        limit\n      } = data.payload;\n\n      if (messageMap[conversationId] && messageMap[conversationId].fetching) {\n        // do nothing if it is fetching\n        return;\n      }\n\n      yield put(fetchingMessage({\n        conversationId\n      }));\n      const resp = yield messageService.getMessages(conversationId, {\n        offset,\n        limit\n      });\n      yield put(loadMoreMessagesSuccess({\n        conversationId,\n        items: resp.data.data,\n        total: resp.data.total\n      }));\n    } catch (e) {\n      message.error('Error occured, please try again later');\n      yield put(loadMoreMessagesFail(e));\n    }\n  }\n\n}, {\n  on: sendMessage,\n\n  *worker(req) {\n    try {\n      const {\n        conversationId,\n        data\n      } = req.payload;\n      const resp = yield messageService.sendMessage(conversationId, data);\n      yield put(sendMessageSuccess(resp.data));\n      yield put(updateLastMessage({\n        conversationId,\n        lastMessage: data.text\n      }));\n    } catch (e) {\n      yield put(sendMessageFail(e));\n    }\n  }\n\n}];\nexport default flatten([createSagas(conversationSagas), createSagas(messageSagas)]);","map":{"version":3,"sources":["E:/programData/React/user/src/redux/message/sagas.ts"],"names":["flatten","put","select","createSagas","messageService","message","getConversations","getConversationsSuccess","getConversationsFail","setActiveConversation","setActiveConversationSuccess","loadMessages","fetchingMessage","loadMessagesSuccess","sendMessage","sendMessageFail","sendMessageSuccess","getConversationDetail","getConversationDetailSuccess","readMessages","loadMoreMessages","loadMoreMessagesSuccess","searchConversations","searchConversationsFail","searchConversationsSuccess","updateLastMessage","loadMoreMessagesFail","loadMessagesFail","setActiveConversationFail","conversationSagas","on","worker","data","resp","payload","e","error","Promise","resolve","source","sourceId","conversationId","recipientId","conversationMapping","state","conversation","mapping","readAllMessages","readAllInConversation","limit","offset","createConversation","_id","id","messageSagas","messageMap","fetching","getMessages","items","total","req","lastMessage","text"],"mappings":"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","sourcesContent":["import { flatten } from 'lodash';\nimport { put, select } from 'redux-saga/effects';\nimport { createSagas } from '@lib/redux';\nimport { messageService } from '@services/message.service';\nimport { IReduxAction } from 'src/interfaces';\nimport { message } from 'antd';\nimport {\n  getConversations,\n  getConversationsSuccess,\n  getConversationsFail,\n  setActiveConversation,\n  setActiveConversationSuccess,\n  loadMessages,\n  fetchingMessage,\n  loadMessagesSuccess,\n  sendMessage,\n  sendMessageFail,\n  sendMessageSuccess,\n  getConversationDetail,\n  getConversationDetailSuccess,\n  readMessages,\n  loadMoreMessages,\n  loadMoreMessagesSuccess,\n  searchConversations,\n  searchConversationsFail,\n  searchConversationsSuccess,\n  updateLastMessage,\n  loadMoreMessagesFail,\n  loadMessagesFail,\n  setActiveConversationFail\n} from './actions';\n\nconst conversationSagas = [\n  {\n    on: getConversations,\n    * worker(data: IReduxAction<Record<string, string>>) {\n      try {\n        const resp = yield messageService.getConversations(data.payload);\n        yield put(getConversationsSuccess(resp.data));\n      } catch (e) {\n        // TODO - alert error\n        const error = yield Promise.resolve(e);\n        yield put(getConversationsFail(error));\n      }\n    }\n  },\n  {\n    on: searchConversations,\n    * worker(data: IReduxAction<Record<string, string>>) {\n      try {\n        const resp = yield messageService.getConversations(data.payload);\n        yield put(searchConversationsSuccess(resp.data));\n      } catch (e) {\n        // TODO - alert error\n        const error = yield Promise.resolve(e);\n        yield put(searchConversationsFail(error));\n      }\n    }\n  },\n  {\n    on: setActiveConversation,\n    * worker(data: IReduxAction<Record<string, string>>) {\n      try {\n        const {\n          source, sourceId, conversationId, recipientId\n        } = data.payload;\n        const conversationMapping = yield select((state) => state.conversation.mapping);\n        if (conversationId) {\n          // todo - check me later\n\n          if (conversationMapping[conversationId]) {\n            yield put(\n              setActiveConversationSuccess(conversationMapping[conversationId])\n            );\n\n            const readAllMessages = yield messageService.readAllInConversation(conversationId, recipientId);\n            if (readAllMessages) {\n              yield put(readMessages(conversationId));\n            }\n            yield put(loadMessages({ conversationId, limit: 25, offset: 0 }));\n          } else {\n            // TODO - check me later, query to DB and update here\n          }\n        } else {\n          const resp = yield messageService.createConversation({\n            source,\n            sourceId\n          });\n          const conversation = resp.data;\n          if (conversationMapping[conversation._id]) {\n            yield put(setActiveConversationSuccess(conversationMapping[conversation._id]));\n          } else {\n            yield put(setActiveConversationSuccess(conversation));\n          }\n          yield put(loadMessages({ conversationId: conversation._id, limit: 25, offset: 0 }));\n        }\n      } catch (e) {\n        message.error('Error occured, please try again later');\n        yield put(setActiveConversationFail(e));\n      }\n    }\n  },\n  {\n    on: getConversationDetail,\n    * worker(data: IReduxAction<Record<string, string>>) {\n      try {\n        const conversation = yield messageService.getConversationDetail(data.payload.id);\n        yield put(getConversationDetailSuccess(conversation.data));\n      } catch (e) {\n        yield put(getConversationsFail(e));\n      }\n    }\n  }\n];\n\nconst messageSagas = [\n  {\n    on: loadMessages,\n    * worker(data: IReduxAction<Record<string, any>>) {\n      try {\n        const messageMap = select((state) => state.message.mapping);\n        const { conversationId, offset, limit } = data.payload;\n        if (messageMap[conversationId] && messageMap[conversationId].fetching) {\n          // do nothing if it is fetching\n          return;\n        }\n        yield put(fetchingMessage({ conversationId }));\n        const resp = yield messageService.getMessages(conversationId, { offset, limit });\n        yield put(\n          loadMessagesSuccess({\n            conversationId,\n            items: resp.data.data,\n            total: resp.data.total\n          })\n        );\n      } catch (e) {\n        message.error('Error occured, please try again later');\n        yield put(loadMessagesFail(e));\n      }\n    }\n  },\n  {\n    on: loadMoreMessages,\n    * worker(data: IReduxAction<Record<string, any>>) {\n      try {\n        const messageMap = select((state) => state.message.mapping);\n        const { conversationId, offset, limit } = data.payload;\n        if (messageMap[conversationId] && messageMap[conversationId].fetching) {\n          // do nothing if it is fetching\n          return;\n        }\n        yield put(fetchingMessage({ conversationId }));\n        const resp = yield messageService.getMessages(conversationId, { offset, limit });\n        yield put(\n          loadMoreMessagesSuccess({\n            conversationId,\n            items: resp.data.data,\n            total: resp.data.total\n          })\n        );\n      } catch (e) {\n        message.error('Error occured, please try again later');\n        yield put(loadMoreMessagesFail(e));\n      }\n    }\n  },\n  {\n    on: sendMessage,\n    * worker(req: IReduxAction<any>) {\n      try {\n        const { conversationId, data } = req.payload;\n        const resp = yield messageService.sendMessage(conversationId, data);\n        yield put(sendMessageSuccess(resp.data));\n        yield put(updateLastMessage({ conversationId, lastMessage: data.text }));\n      } catch (e) {\n        yield put(sendMessageFail(e));\n      }\n    }\n  }\n];\n\nexport default flatten([\n  createSagas(conversationSagas),\n  createSagas(messageSagas)\n]);\n"]},"metadata":{},"sourceType":"module"}