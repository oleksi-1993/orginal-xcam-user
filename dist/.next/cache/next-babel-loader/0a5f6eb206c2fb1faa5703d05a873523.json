{"ast":null,"code":"var _jsxFileName = \"E:\\\\programData\\\\React\\\\user\\\\pages\\\\performer-category\\\\index.tsx\";\nvar __jsx = React.createElement;\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport React, { PureComponent } from 'react';\nimport { connect } from 'react-redux';\nimport { message } from 'antd';\nimport PageHeader from '@components/common/layout/page-header';\nimport { performerCategories } from 'src/services/perfomer-categories.service';\nimport { updateUIValue } from 'src/redux/ui/actions';\nimport Head from 'next/head';\nimport PerformerGrid from '@components/performer/performer-grid';\nimport { searchPerformer, updatePerformerFavourite } from '@redux/performer/actions';\nimport { favouriteService } from 'src/services';\nimport { getResponseError } from 'src/lib';\nimport { SocketContext } from 'src/socket';\nconst initQueryState = {\n  offset: 0,\n  limit: 60,\n  gender: '',\n  category: '',\n  country: '',\n  sortBy: '',\n  sort: 'desc'\n};\n\nclass PerformerCategoryPage extends PureComponent {\n  static async getInitialProps({\n    ctx\n  }) {\n    try {\n      if (false && ctx.query.category) {\n        return {\n          category: JSON.parse(ctx.query.category)\n        };\n      }\n\n      if (!ctx.query.slug) {\n        return {};\n      }\n\n      const resp = await performerCategories.details(ctx.query.slug);\n      return {\n        category: resp.data\n      };\n    } catch (err) {\n      return {};\n    }\n  }\n\n  constructor(props) {\n    super(props);\n\n    _defineProperty(this, \"socket\", void 0);\n\n    _defineProperty(this, \"search\", () => {\n      const {\n        searchPerformer: dispatchSearchPerformer,\n        category\n      } = this.props;\n      const {\n        query\n      } = this.state;\n      dispatchSearchPerformer(_objectSpread(_objectSpread({}, query), {}, {\n        category: category ? category._id : ''\n      }));\n    });\n\n    this.state = {\n      query: initQueryState\n    };\n  }\n\n  componentDidMount() {\n    this.search();\n    this.socket = this.context;\n    this.socket.on('modelUpdateStatus', this.search);\n    this.socket.on('modelUpdateStreamingStatus', this.search);\n  }\n\n  componentDidUpdate(prevProps) {\n    const {\n      category,\n      loggedIn\n    } = this.props;\n\n    if (category !== prevProps.category) {\n      this.search();\n    }\n\n    if (!loggedIn && loggedIn !== prevProps.loggedIn) {\n      this.search();\n    }\n  }\n\n  componentWillUnmount() {\n    this.socket = this.context;\n\n    if (this.socket) {\n      this.socket.off('modelUpdateStatus');\n      this.socket.off('modelUpdateStreamingStatus');\n    }\n  }\n\n  async onLike(performer) {\n    const {\n      _id,\n      isFavorite\n    } = performer;\n    const {\n      updatePerformerFavourite: dispatchUpdatePerformerFavourite\n    } = this.props;\n\n    try {\n      await favouriteService.favorite(_id, isFavorite);\n      dispatchUpdatePerformerFavourite(_id);\n    } catch (error) {\n      const e = await Promise.resolve(error);\n      message.error(getResponseError(e));\n    }\n  }\n\n  setFilter(name, value) {\n    const {\n      query\n    } = this.state;\n    this.setState({\n      query: _objectSpread(_objectSpread({}, query), {}, {\n        [name]: value\n      })\n    });\n  }\n\n  render() {\n    const {\n      category,\n      pluralTextModel\n    } = this.props;\n    const {\n      query\n    } = this.state;\n    return __jsx(React.Fragment, null, __jsx(Head, {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 154,\n        columnNumber: 9\n      }\n    }, __jsx(\"title\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 155,\n        columnNumber: 11\n      }\n    }, category ? `Category - ${category.name}` : `All ${pluralTextModel || 'Performers'}`)), __jsx(PageHeader, {\n      title: category ? category.name : `All ${pluralTextModel || 'Performers'}`,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 159,\n        columnNumber: 9\n      }\n    }), __jsx(\"div\", {\n      className: \"\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 160,\n        columnNumber: 9\n      }\n    }, __jsx(PerformerGrid, _extends({}, this.props, query, {\n      isPage: true,\n      setFilter: this.setFilter.bind(this),\n      onLike: this.onLike.bind(this),\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 161,\n        columnNumber: 11\n      }\n    }))));\n  }\n\n}\n\n_defineProperty(PerformerCategoryPage, \"authenticate\", false);\n\n_defineProperty(PerformerCategoryPage, \"layout\", 'public');\n\nPerformerCategoryPage.contextType = SocketContext;\n\nconst mapStateToProps = state => _objectSpread(_objectSpread({\n  loggedIn: state.auth.loggedIn\n}, state.performer.performers), state.ui);\n\nconst mapDispatch = {\n  searchPerformer,\n  updatePerformerFavourite,\n  updateUIValue\n};\nexport default connect(mapStateToProps, mapDispatch)(PerformerCategoryPage);","map":{"version":3,"sources":["E:/programData/React/user/pages/performer-category/index.tsx"],"names":["React","PureComponent","connect","message","PageHeader","performerCategories","updateUIValue","Head","PerformerGrid","searchPerformer","updatePerformerFavourite","favouriteService","getResponseError","SocketContext","initQueryState","offset","limit","gender","category","country","sortBy","sort","PerformerCategoryPage","getInitialProps","ctx","query","JSON","parse","slug","resp","details","data","err","constructor","props","dispatchSearchPerformer","state","_id","componentDidMount","search","socket","context","on","componentDidUpdate","prevProps","loggedIn","componentWillUnmount","off","onLike","performer","isFavorite","dispatchUpdatePerformerFavourite","favorite","error","e","Promise","resolve","setFilter","name","value","setState","render","pluralTextModel","bind","contextType","mapStateToProps","auth","performers","ui","mapDispatch"],"mappings":"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","sourcesContent":["import React, { PureComponent } from 'react';\nimport { connect } from 'react-redux';\nimport { message } from 'antd';\nimport PageHeader from '@components/common/layout/page-header';\nimport { performerCategories } from 'src/services/perfomer-categories.service';\nimport { updateUIValue } from 'src/redux/ui/actions';\nimport {\n  IPerformerCategogies,\n  IResponse,\n  IPerformer,\n  IPerformSearch\n} from 'src/interfaces';\nimport Head from 'next/head';\nimport PerformerGrid from '@components/performer/performer-grid';\nimport {\n  searchPerformer,\n  updatePerformerFavourite\n} from '@redux/performer/actions';\nimport { favouriteService } from 'src/services';\nimport { getResponseError } from 'src/lib';\nimport { SocketContext } from 'src/socket';\n\ninterface IProps {\n  category: IPerformerCategogies;\n  data: IPerformer[];\n  searchPerformer: Function;\n  total: number;\n  success: boolean;\n  searching: boolean;\n  loggedIn: boolean;\n  error: any;\n  updatePerformerFavourite: Function;\n  pluralTextModel: string;\n}\n\ninterface IStates {\n  query: IPerformSearch;\n  sort?: {\n    name: string;\n    sortBy?: string;\n  };\n}\n\nconst initQueryState: IPerformSearch = {\n  offset: 0,\n  limit: 60,\n  gender: '',\n  category: '',\n  country: '',\n  sortBy: '',\n  sort: 'desc'\n};\n\nclass PerformerCategoryPage extends PureComponent<IProps, IStates> {\n  static authenticate = false;\n\n  static layout = 'public';\n\n  private socket;\n\n  static async getInitialProps({ ctx }) {\n    try {\n      if (process.browser && ctx.query.category) {\n        return {\n          category: JSON.parse(ctx.query.category)\n        };\n      }\n\n      if (!ctx.query.slug) {\n        return {};\n      }\n\n      const resp: IResponse<IPerformerCategogies> = await performerCategories.details(\n        ctx.query.slug\n      );\n\n      return {\n        category: resp.data\n      };\n    } catch (err) {\n      return {};\n    }\n  }\n\n  constructor(props: IProps) {\n    super(props);\n    this.state = {\n      query: initQueryState\n    };\n  }\n\n  componentDidMount() {\n    this.search();\n    this.socket = this.context;\n    this.socket.on('modelUpdateStatus', this.search);\n    this.socket.on('modelUpdateStreamingStatus', this.search);\n  }\n\n  componentDidUpdate(prevProps: IProps) {\n    const { category, loggedIn } = this.props;\n    if (category !== prevProps.category) {\n      this.search();\n    }\n    if (!loggedIn && loggedIn !== prevProps.loggedIn) {\n      this.search();\n    }\n  }\n\n  componentWillUnmount() {\n    this.socket = this.context;\n    if (this.socket) {\n      this.socket.off('modelUpdateStatus');\n      this.socket.off('modelUpdateStreamingStatus');\n    }\n  }\n\n  async onLike(performer: IPerformer) {\n    const { _id, isFavorite } = performer;\n    const { updatePerformerFavourite: dispatchUpdatePerformerFavourite } = this.props;\n    try {\n      await favouriteService.favorite(_id, isFavorite);\n      dispatchUpdatePerformerFavourite(_id);\n    } catch (error) {\n      const e = await Promise.resolve(error);\n      message.error(getResponseError(e));\n    }\n  }\n\n  setFilter(name: string, value: any) {\n    const { query } = this.state;\n    this.setState({\n      query: {\n        ...query,\n        [name]: value\n      }\n    });\n  }\n\n  search = () => {\n    const { searchPerformer: dispatchSearchPerformer, category } = this.props;\n    const { query } = this.state;\n    dispatchSearchPerformer({\n      ...query,\n      category: category ? category._id : ''\n    });\n  }\n\n  render() {\n    const { category, pluralTextModel } = this.props;\n    const { query } = this.state;\n\n    return (\n      <>\n        <Head>\n          <title>\n            {category ? `Category - ${category.name}` : `All ${pluralTextModel || 'Performers'}`}\n          </title>\n        </Head>\n        <PageHeader title={category ? category.name : `All ${pluralTextModel || 'Performers'}`} />\n        <div className=\"\">\n          <PerformerGrid\n            {...this.props}\n            {...query}\n            isPage\n            setFilter={this.setFilter.bind(this)}\n            onLike={this.onLike.bind(this)}\n          />\n        </div>\n      </>\n    );\n  }\n}\n\nPerformerCategoryPage.contextType = SocketContext;\n\nconst mapStateToProps = (state) => ({\n  loggedIn: state.auth.loggedIn,\n  ...state.performer.performers,\n  ...state.ui\n});\nconst mapDispatch = { searchPerformer, updatePerformerFavourite, updateUIValue };\n\nexport default connect(mapStateToProps, mapDispatch)(PerformerCategoryPage);\n"]},"metadata":{},"sourceType":"module"}