{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nvar _jsxFileName = \"E:\\\\programData\\\\React\\\\user\\\\src\\\\components\\\\messages\\\\MessageList.tsx\";\nvar __jsx = React.createElement;\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nimport React, { PureComponent, createRef } from 'react';\nimport { connect } from 'react-redux';\nimport moment from 'moment';\nimport '../stream-chat/MessageList.less';\nimport { loadMoreMessages } from '@redux/message/actions';\nimport Compose from './Compose';\nimport Message from './Message';\n\nvar MessageList = /*#__PURE__*/function (_PureComponent) {\n  _inherits(MessageList, _PureComponent);\n\n  var _super = _createSuper(MessageList);\n\n  function MessageList() {\n    var _this;\n\n    _classCallCheck(this, MessageList);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n\n    _defineProperty(_assertThisInitialized(_this), \"messagesRef\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"state\", {\n      offset: 1,\n      onloadmore: false\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"renderMessages\", function () {\n      var _this$props = _this.props,\n          message = _this$props.message,\n          currentUser = _this$props.currentUser,\n          currentPerformer = _this$props.currentPerformer;\n      var messages = message.items;\n      var i = 0;\n      var messageCount = messages.length;\n      var tempMessages = [];\n\n      while (i < messageCount) {\n        var previous = messages[i - 1];\n        var current = messages[i];\n        var next = messages[i + 1];\n        var isMine = current.senderId === (currentUser && currentUser._id || currentPerformer && currentPerformer._id);\n        var currentMoment = moment(current.createdAt);\n        var prevBySameAuthor = false;\n        var nextBySameAuthor = false;\n        var startsSequence = true;\n        var endsSequence = true;\n        var showTimestamp = true;\n\n        if (previous) {\n          var previousMoment = moment(previous.createdAt);\n          var previousDuration = moment.duration(currentMoment.diff(previousMoment));\n          prevBySameAuthor = previous.senderId === current.senderId;\n\n          if (prevBySameAuthor && previousDuration.as('hours') < 1) {\n            startsSequence = false;\n          }\n\n          if (previousDuration.as('hours') < 1) {\n            showTimestamp = false;\n          }\n        }\n\n        if (next) {\n          var nextMoment = moment(next.createdAt);\n          var nextDuration = moment.duration(nextMoment.diff(currentMoment));\n          nextBySameAuthor = next.senderId === current.senderId;\n\n          if (nextBySameAuthor && nextDuration.as('hours') < 1) {\n            endsSequence = false;\n          }\n        }\n\n        if (current._id) {\n          tempMessages.push(__jsx(Message, {\n            key: i,\n            isMine: isMine,\n            startsSequence: startsSequence,\n            endsSequence: endsSequence,\n            showTimestamp: showTimestamp,\n            data: current,\n            __self: _assertThisInitialized(_this),\n            __source: {\n              fileName: _jsxFileName,\n              lineNumber: 120,\n              columnNumber: 11\n            }\n          }));\n        } // Proceed to the next message.\n\n\n        i += 1;\n      }\n\n      _this.scrollToBottom();\n\n      return tempMessages;\n    });\n\n    return _this;\n  }\n\n  _createClass(MessageList, [{\n    key: \"componentDidMount\",\n    value: function () {\n      var _componentDidMount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!this.messagesRef) this.messagesRef = /*#__PURE__*/createRef();\n\n              case 1:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function componentDidMount() {\n        return _componentDidMount.apply(this, arguments);\n      }\n\n      return componentDidMount;\n    }()\n  }, {\n    key: \"componentDidUpdate\",\n    value: function () {\n      var _componentDidUpdate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(prevProps) {\n        var _this$props2, conversation, message, onloadmore, messages;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _this$props2 = this.props, conversation = _this$props2.conversation, message = _this$props2.message;\n                onloadmore = this.state.onloadmore;\n                messages = message.items;\n\n                if (prevProps && prevProps.conversation && prevProps.conversation._id !== conversation._id) {\n                  this.setOffset();\n                }\n\n                if (messages !== prevProps.message.items) {\n                  if (onloadmore) {\n                    // eslint-disable-next-line react/no-did-update-set-state\n                    this.setState({\n                      onloadmore: false\n                    });\n                  } else {\n                    this.scrollToBottom();\n                  }\n                }\n\n              case 5:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function componentDidUpdate(_x) {\n        return _componentDidUpdate.apply(this, arguments);\n      }\n\n      return componentDidUpdate;\n    }()\n  }, {\n    key: \"handleScroll\",\n    value: function () {\n      var _handleScroll = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(conversation, event) {\n        var _this$props3, message, dispatchLoadMoreMessages, fetching, items, total, offset, canloadmore, ele;\n\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _this$props3 = this.props, message = _this$props3.message, dispatchLoadMoreMessages = _this$props3.loadMoreMessages;\n                fetching = message.fetching, items = message.items, total = message.total;\n                offset = this.state.offset;\n                canloadmore = total > items.length;\n                ele = event.target;\n\n                if (canloadmore) {\n                  _context3.next = 7;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\");\n\n              case 7:\n                if (!(ele.scrollTop === 0 && conversation._id && !fetching && canloadmore)) {\n                  _context3.next = 11;\n                  break;\n                }\n\n                _context3.next = 10;\n                return this.setState({\n                  offset: offset + 1,\n                  onloadmore: true\n                });\n\n              case 10:\n                dispatchLoadMoreMessages({\n                  conversationId: conversation._id,\n                  limit: 20,\n                  offset: (offset - 1) * 20\n                });\n\n              case 11:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function handleScroll(_x2, _x3) {\n        return _handleScroll.apply(this, arguments);\n      }\n\n      return handleScroll;\n    }()\n  }, {\n    key: \"setOffset\",\n    value: function () {\n      var _setOffset = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                this.setState({\n                  offset: 1\n                });\n\n              case 1:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function setOffset() {\n        return _setOffset.apply(this, arguments);\n      }\n\n      return setOffset;\n    }()\n  }, {\n    key: \"scrollToBottom\",\n    value: function scrollToBottom() {\n      var onloadmore = this.state.onloadmore;\n\n      if (onloadmore) {\n        return;\n      }\n\n      if (this.messagesRef && this.messagesRef.current) {\n        var ele = this.messagesRef.current;\n        window.setTimeout(function () {\n          ele.scrollTop = ele.scrollHeight;\n        }, 100);\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$props4 = this.props,\n          conversation = _this$props4.conversation,\n          message = _this$props4.message;\n      var fetching = message.fetching;\n      if (!this.messagesRef) this.messagesRef = /*#__PURE__*/createRef();\n      return __jsx(\"div\", {\n        className: \"message-list custom\",\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 155,\n          columnNumber: 7\n        }\n      }, conversation && conversation._id ? __jsx(React.Fragment, null, __jsx(\"div\", {\n        className: \"message-list-container\",\n        ref: this.messagesRef,\n        onScroll: this.handleScroll.bind(this, conversation),\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 158,\n          columnNumber: 13\n        }\n      }, fetching && __jsx(\"p\", {\n        className: \"text-center\",\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 163,\n          columnNumber: 28\n        }\n      }, \"fetching...\"), this.renderMessages()), __jsx(Compose, {\n        conversation: conversation,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 167,\n          columnNumber: 13\n        }\n      })) : __jsx(\"div\", {\n        className: \"start-conversation\",\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 170,\n          columnNumber: 11\n        }\n      }, __jsx(\"p\", {\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 171,\n          columnNumber: 13\n        }\n      }, \"Click conversation to start\")));\n    }\n  }]);\n\n  return MessageList;\n}(PureComponent);\n\nvar mapStates = function mapStates(state) {\n  var conversationMap = state.message.conversationMap;\n  var activeConversation = state.conversation.activeConversation;\n  var messages = conversationMap[activeConversation._id] ? conversationMap[activeConversation._id].items || [] : [];\n  var totalMessages = conversationMap[activeConversation._id] ? conversationMap[activeConversation._id].total || 0 : 0;\n  var fetching = conversationMap[activeConversation._id] ? conversationMap[activeConversation._id].fetching || false : false;\n  return {\n    message: {\n      items: messages,\n      total: totalMessages,\n      fetching: fetching\n    },\n    conversation: activeConversation,\n    currentUser: state.user.current,\n    currentPerformer: state.performer.current\n  };\n};\n\nvar mapDispatch = {\n  loadMoreMessages: loadMoreMessages\n};\nexport default connect(mapStates, mapDispatch)(MessageList);","map":{"version":3,"sources":["E:/programData/React/user/src/components/messages/MessageList.tsx"],"names":["React","PureComponent","createRef","connect","moment","loadMoreMessages","Compose","Message","MessageList","offset","onloadmore","props","message","currentUser","currentPerformer","messages","items","i","messageCount","length","tempMessages","previous","current","next","isMine","senderId","_id","currentMoment","createdAt","prevBySameAuthor","nextBySameAuthor","startsSequence","endsSequence","showTimestamp","previousMoment","previousDuration","duration","diff","as","nextMoment","nextDuration","push","scrollToBottom","messagesRef","prevProps","conversation","state","setOffset","setState","event","dispatchLoadMoreMessages","fetching","total","canloadmore","ele","target","scrollTop","conversationId","limit","window","setTimeout","scrollHeight","handleScroll","bind","renderMessages","mapStates","conversationMap","activeConversation","totalMessages","user","performer","mapDispatch"],"mappings":"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","sourcesContent":["import React, { PureComponent, Fragment, createRef } from 'react';\nimport { connect } from 'react-redux';\nimport moment from 'moment';\nimport '../stream-chat/MessageList.less';\nimport { loadMoreMessages } from '@redux/message/actions';\nimport { IPerformer } from 'src/interfaces';\nimport Compose from './Compose';\nimport Message from './Message';\n\ninterface IProps {\n  loadMoreMessages: Function;\n  message: any;\n  conversation: any;\n  currentUser: any;\n  currentPerformer: IPerformer;\n}\n\nclass MessageList extends PureComponent<IProps> {\n  messagesRef: any;\n\n  state = {\n    offset: 1,\n    onloadmore: false\n  };\n\n  async componentDidMount() {\n    if (!this.messagesRef) this.messagesRef = createRef();\n  }\n\n  async componentDidUpdate(prevProps: IProps) {\n    const { conversation, message } = this.props;\n    const { onloadmore } = this.state;\n    const messages = message.items;\n    if (\n      prevProps\n      && prevProps.conversation\n      && prevProps.conversation._id !== conversation._id\n    ) {\n      this.setOffset();\n    }\n\n    if (messages !== prevProps.message.items) {\n      if (onloadmore) {\n        // eslint-disable-next-line react/no-did-update-set-state\n        this.setState({ onloadmore: false });\n      } else {\n        this.scrollToBottom();\n      }\n    }\n  }\n\n  async handleScroll(conversation, event) {\n    const { message, loadMoreMessages: dispatchLoadMoreMessages } = this.props;\n    const { fetching, items, total } = message;\n    const { offset } = this.state;\n    const canloadmore = total > items.length;\n    const ele = event.target;\n    if (!canloadmore) return;\n    if (ele.scrollTop === 0 && conversation._id && !fetching && canloadmore) {\n      await this.setState({ offset: offset + 1, onloadmore: true });\n      dispatchLoadMoreMessages({\n        conversationId: conversation._id,\n        limit: 20,\n        offset: (offset - 1) * 20\n      });\n    }\n  }\n\n  async setOffset() {\n    this.setState({ offset: 1 });\n  }\n\n  renderMessages = () => {\n    const { message, currentUser, currentPerformer } = this.props;\n    const messages = message.items;\n    let i = 0;\n    const messageCount = messages.length;\n    const tempMessages = [];\n    while (i < messageCount) {\n      const previous = messages[i - 1];\n      const current = messages[i];\n      const next = messages[i + 1];\n      const isMine = current.senderId\n        === ((currentUser && currentUser._id)\n          || (currentPerformer && currentPerformer._id));\n      const currentMoment = moment(current.createdAt);\n      let prevBySameAuthor = false;\n      let nextBySameAuthor = false;\n      let startsSequence = true;\n      let endsSequence = true;\n      let showTimestamp = true;\n\n      if (previous) {\n        const previousMoment = moment(previous.createdAt);\n        const previousDuration = moment.duration(\n          currentMoment.diff(previousMoment)\n        );\n        prevBySameAuthor = previous.senderId === current.senderId;\n\n        if (prevBySameAuthor && previousDuration.as('hours') < 1) {\n          startsSequence = false;\n        }\n\n        if (previousDuration.as('hours') < 1) {\n          showTimestamp = false;\n        }\n      }\n\n      if (next) {\n        const nextMoment = moment(next.createdAt);\n        const nextDuration = moment.duration(nextMoment.diff(currentMoment));\n        nextBySameAuthor = next.senderId === current.senderId;\n\n        if (nextBySameAuthor && nextDuration.as('hours') < 1) {\n          endsSequence = false;\n        }\n      }\n      if (current._id) {\n        tempMessages.push(\n          <Message\n            key={i}\n            isMine={isMine}\n            startsSequence={startsSequence}\n            endsSequence={endsSequence}\n            showTimestamp={showTimestamp}\n            data={current}\n          />\n        );\n      }\n      // Proceed to the next message.\n      i += 1;\n    }\n    this.scrollToBottom();\n    return tempMessages;\n  };\n\n  scrollToBottom() {\n    const { onloadmore } = this.state;\n    if (onloadmore) {\n      return;\n    }\n    if (this.messagesRef && this.messagesRef.current) {\n      const ele = this.messagesRef.current;\n      window.setTimeout(() => {\n        ele.scrollTop = ele.scrollHeight;\n      }, 100);\n    }\n  }\n\n  render() {\n    const { conversation, message } = this.props;\n    const { fetching } = message;\n    if (!this.messagesRef) this.messagesRef = createRef();\n    return (\n      <div className=\"message-list custom\">\n        {conversation && conversation._id ? (\n          <>\n            <div\n              className=\"message-list-container\"\n              ref={this.messagesRef}\n              onScroll={this.handleScroll.bind(this, conversation)}\n            >\n              {fetching && <p className=\"text-center\">fetching...</p>}\n              {this.renderMessages()}\n            </div>\n\n            <Compose conversation={conversation} />\n          </>\n        ) : (\n          <div className=\"start-conversation\">\n            <p>Click conversation to start</p>\n          </div>\n        )}\n      </div>\n    );\n  }\n}\n\nconst mapStates = (state: any) => {\n  const { conversationMap } = state.message;\n  const { activeConversation } = state.conversation;\n  const messages = conversationMap[activeConversation._id]\n    ? conversationMap[activeConversation._id].items || []\n    : [];\n  const totalMessages = conversationMap[activeConversation._id]\n    ? conversationMap[activeConversation._id].total || 0\n    : 0;\n  const fetching = conversationMap[activeConversation._id]\n    ? conversationMap[activeConversation._id].fetching || false\n    : false;\n  return {\n    message: {\n      items: messages,\n      total: totalMessages,\n      fetching\n    },\n    conversation: activeConversation,\n    currentUser: state.user.current,\n    currentPerformer: state.performer.current\n  };\n};\n\nconst mapDispatch = { loadMoreMessages };\nexport default connect(mapStates, mapDispatch)(MessageList);\n"]},"metadata":{},"sourceType":"module"}